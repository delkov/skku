HOTKEYS:
CTRL+L - выделить строку
CTRL+DEL/ CTRL+BASKSPACE - delete word befor after 
CTRL+SHIFT+K - remove line
CTRL+SHIFT+D - duplicate lne

CTRL +P - change file
CTRL+F2 - make bookmars
CTRL+PGUP/DOWN - go to file
F2 - fo to bookmrark
CTRL+SHIFT+F@ -del all bookmarks
CTRL+G - go to line


a[::-1]
[5,4,3,2,1]

x = 3 if (y == 1) else 2 if (y == -1) else 1

 (func1 if y == 1 else func2)(arg1, arg2)


 >>> del s[3: -2: 2] #удаляем элементы между третьим и предпоследним с шагом 2
>>> s
[ 0, 1, 2, 4, 6, 8, 9]


Проблема в том, что обычно вам всё равно нужны элементы списка. Что толку от индексов без них? В Python есть потрясающая встроенная функция enumerate, которая воозвращает итератор для пар индекс → значение:
Copy Source | Copy HTML
strings = ['a', 'b', 'c', 'd', 'e']
for index, string in enumerate(strings):
    print index, string,
# печатает "0 a 1 b 2 c 3 d 4 e"


>>> l = [[1, 2, 3], [4, 5], [6], [7, 8, 9]]
>>> sum(l, [])
[1, 2, 3, 4, 5, 6, 7, 8, 9]

Генератором списков (спасибоmagic4x):
[y for x in data for y in x]


>>> def foo(x=None):
...     if x is None:
...         x = []
...     x.append(1)
...     print x
>>> foo()
[1]
>>> foo()
[1]

numbers = (1,2,3,4,5) # мы стремимся к эффективной работе, поэтому используем кортеж вместо списка ;)
squares_under_10 = (number*number for number in numbers if number*number < 10)
# squares_under_10 - generator object, из которого можно получить следующее значение, вызвав метод .next()

for square in squares_under_10:
    print square,
#выводит '1 4 9'

Это более эффективно, чем использование генератора списков.

def f(a, *pargs, **kargs): print(a, pargs, kargs)
f(1, 2, 3, x=1, y=2)
1 (2, 3) {‘y’: 2, ‘x’: 1}


func(*(1, 2), **{‘d’: 4, ‘c’: 4})
1 2 4 4


def func(a, b, c, d): print(a, b, c, d)

func(*(1, 2), **{'d': 4, 'c': 4})



3 in L
L.append(4)
L.extend([5,6,7])
L.insert(I, X)
L[i] = 1
L[i:j] = [4,5,6]
L = [x**2 for x in range(5)]
list(map(ord, ‘spam’))

D = {}
D = {‘spam’: 2, ‘eggs’: 3}
D = {‘food’: {‘ham’: 1, ‘egg’: 2}}
D = dict(name=’Bob’, age=40)
D = dict(zip(keyslist, valslist))
D = dict.fromkeys([‘a’, ‘b’])
D[‘eggs’]
D[‘food’][‘ham’]
‘eggs’ in D
D.keys()
D.values()
D.items()
D.copy()
D.get(key, default)
D.update(D2)
D.pop(key)
len(D)
D[key] = 42
del D[key]
list(D.keys())
D1.keys() & D2.keys()
D = {x: x*2 for x in range(10)}


list(zip([‘a’, ‘b’, ‘c’], [1, 2, 3])) # Объединить ключи и значения
[(‘a’, 1), (‘b’, 2), (‘c’, 3)]
D = dict(zip([‘a’, ‘b’, ‘c’], [1, 2, 3]))
D = {‘a’: 1, ‘c’: 3, ‘b’: 2}

D = {k: v for (k, v) in zip([‘a’, ‘b’, ‘c’], [1, 2, 3])}

X = L * 4
# Все равно, что [4, 5, 6] + [4, 5, 6] + ...
Y = [L] * 4
 # [L] + [L] + ... = [L, L,...]
X
[4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]
>>> Y
[[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]

for (a, b, c) in [(1, 2, 3), (4, 5, 6)]: ...
 

a, *b, c = seq

Блок else в циклах while или for выполняется один раз после выхода из
цикла при условии, что цикл завершается обычным образом (без исполь-
зования инструкции break). Инструкция break осуществляет немедленный
выход из цикла и пропускает блок else (если таковая присутствует).


Чтение через генераторы
>>> lines = [line.rstrip() for line in open(‘script1.py’) if line[0] == ‘p’]
>>> lines
[‘print(sys.path)’, ‘print(2 ** 33)’]


>>> [x + y for x in ‘abc’ for y in ‘lmn’]
[‘al’, ‘am’, ‘an’, ‘bl’, ‘bm’, ‘bn’, ‘cl’, ‘cm’, ‘cn’]

{line for line in open(‘script1.py’) if line[0] == ‘p’}
{‘print(sys.path)\n’, ‘print(2 ** 33)\n’}

{ix: line for (ix, line) in enumerate(open(‘script1.py’)) if line[0]==’p’}
{1: ‘print(sys.path)\n’, 3: ‘print(2 ** 33)\n’}

for key in sorted(D):
	print(key, D[key])


По умолчанию изменение значения переменной в объемлющей области види-
мости не допускается – это нормальная ситуация и в версии 2.6:
>>> def tester(start):
 state = start
 def nested(label):
 print(label, state)
 state += 1
 # По умолчанию не изменяется (как и в 2.6)
 return nested
>>> F = tester(0)
>>> F(‘spam’)
Если теперь (при условии, что используется Python 3.0) переменную state, ло-
кальную для функции tester, объявить в функции nested с помощью инструк-
ции nonlocal, мы сможем изменять ее внутри функции nested. Этот прием дей-
ствует, даже несмотря на то, что функция tester уже завершила работу к мо-
менту, когда мы вызываем функцию nested через имя F:
Инструкция nonlocal	
def tester(start):
 state = start # В каждом вызове сохраняется свое значение state
 def nested(label):
 nonlocal state
 # Объект state находится
 print(label, state) # в объемлющей области видимости
 state += 1 # Изменит значение переменной, объявленной как nonlocal
 return nested
>>> F = tester(0)
>>> F(‘spam’)
 # Будет увеличивать значение state при каждом вызове
spam 0
>>> F(‘ham’)
ham 1
F(‘eggs’)


>>> def tester(start):
 def nested(label):
 print(label, nested.state) # nested – объемлющая область видимости
 nested.state += 1 # Изменит атрибут, а не значение имени nested
 nested.state = start
 # Инициализация после создания функции
 return nested

>>>
 def changer(a, b):
 a = 2
 b[0] = ‘spam’
 X = 1
 L = [1, 2]
 changer(X, L)
 X, L
(1,
 [‘spam’, 2])
L = [1, 2]
changer(X, L[:]) # Передается копия, поэтому переменная ‘L’ не изменится

>>>
 def multiple(x, y):
 x = 2
 # Изменяется только локальное имя
 y = [3, 4]
 return x, y
 # Новые значения возвращаются в виде кортежа
 X = 1
 L = [1, 2]
 X, L = multiple(X, L)
 # Результаты присваиваются именам
 X, L
 # в вызывающей программе
(2,
 [3, 4])


def mysum(L):
 # Суммирует любые типы
return L[0] if len(L) == 1 else L[0] + mysum(L[1:]) # 


>>> lower = (lambda x, y: x if x < y else y)
>>> lower(‘bb’, ‘aa’)
‘aa’
>>> lower(‘aa’, ‘bb’)
‘aa’

>>> res = [x + y for x in [0, 1, 2] for y in [100, 200, 300]]



Функция map ожидает получить в первом аргументе функцию, поэтому здесь
часто можно встретить lambda-выражения:
>>> list(map((lambda x: x + 3), counters))
[4, 5, 6, 7]

TR = range(10)
print(filter((lambda x: x>0), TR))

>>> reduce((lambda x, y: x + y), [1, 2, 3, 4])
10
>>> reduce((lambda x, y: x * y), [1, 2, 3, 4])
24


>>> res = map(ord, ‘spam’)
>>> res
[115, 112, 97, 109]
# Применить функцию к последовательности
Но те же результаты можно получить с помощью генератора списка – если map
отображает функцию на последовательность, то генератор списков отображает
на последовательность выражение:
>>> res = [ord(x) for x in ‘spam’] # Применит выражение к последовательности
>>> res
[115, 112, 97, 109]


[x ** 2 for x in range(10) if x % 2 == 0]

[(x, y) for x in range(5) if x % 2 == 0 for y in range(5) if y % 2 == 1]

[x ** 2 for x in range(4)]
[0, 1, 4, 9]
# Генератор списков: создает список
>>> (x ** 2 for x in range(4))
<generator object at 0x011DC648>
# Выражение-генератор: создает
# итерируемый объект
Фактически, по крайней мере с функциональной точки зрения, генератор спи-
сков является эквивалентом генератора-выражения, обернутого в вызов встро-
енной функции list для принудительного получения сразу всего списка с ре-
зультатами:
>>> list(x ** 2 for x in range(4)) # Эквивалент генератора списков
[0, 1, 4, 9]

>>> sum(x ** 2 for x in range(4))
14
>>> sorted(x ** 2 for x in range(4))
[0, 1, 4, 9]
>>> sorted((x ** 2 for x in range(4)), reverse=True)
[9, 4, 1, 0]
>>> import math
>>> list(map(math.sqrt, (x ** 2 for x in range(4))))
[0.0, 1.0, 2.0, 3.0]

>>> G = (c * 4 for c in ‘SPAM’) # Выражение-генератор
>>> list(G)
 # Принудительно получить сразу все результаты
[‘SSSS’, ‘PPPP’, ‘AAAA’, ‘MMMM’]
Эквивалентная функция-генератор содержит чуть больше программного кода,
но, будучи функцией, при необходимости способна вместить в себя больший
объем логики и использовать больший объем информации:
>>> def timesfour(S): # Функция-генератор
...
 for c in S:
...
 yield c * 4
...
>>> G = timesfour(‘spam’)
>>> list(G)
 # Выполнит итерации автоматически
[‘ssss’, ‘pppp’, ‘aaaa’, ‘mmmm’]


zip усекает
>>> list(zip([1, 2, 3], [2, 3, 4, 5])) # N последовательностей:
[(1, 2), (2, 3), (3, 4)]
 # N-мерные кортежи

 >>> list(map(pow, [1, 2, 3], [2, 3, 4, 5])) # N последовательностей:
[1, 8, 81]
 # N-мерная функция

>>>
 D = {‘a’:1, ‘b’:2, ‘c’:3}
>>>
 x = iter(D)
>>>
 next(x)
‘a’
>>>
 next(x)


 arr = [1, 2, З, 4, 5, б]
for i, elem in enurnerate(arr):
if elem % 2 == О:
arr[i] *= 2
print(arL") # Результат вЬП1олнения: [1, 4, 3, 8, 5, 12]

>>> irnport сору
 # Подкточаем модуль сору
>>> х = [1, [2, 3, 4, 5]]
>>> у= copy.deepcopy(x)
 # делаем полную копию списка
>>> y[l) (1) = 100
 # Изменяем второй элемент
>>> х, у
 # Изменился только список в переменной у
( [1, [ 2, 3, 4, 5]] , [1, [ 2,
 100, 4, 5] ])


import itertools
for i in itertools.count():
	if i > 10: break
	print(i, end=" ")
О 1 2 3 4 5 6 7 8 9 10


>>> n = 1
>>> for i in itertools.cycle("aбв"):
if n > 10: break
print(i, end=" ")
n +== 1
а о в а б в а с в а
>>> list(zip(itertools.cycle([O, 1)), "абвгд" ))
[(О, 'а'), (1, 'б'), (0, 'в'), (1, 'г'), (О, 


>>> import itertools
>>> list(itertools.comЬinations('aбвг', 2))
(('а', 'б'), ('а', 'в'), ('а', 'г'), ('б', 'в'), ('б', 'г'),
('в', 'г'}]
>>> ["" .join(i} for i in itertools.comЬinations ( 'абвг', 2)]
[
 'аб', 'ав', 'аг', 'бв ', 'бг', 'вг'
 ]
 2))
>>> list(itertools.comЬinations('вгaб',
(('в', 'г'), ('в', 'а'), ('в', 'б'), ('г', 'а'), ('г', 1 6 1
 ),
(•а', 'б')]
>>> list(itertools.comЬinations('aбвг', 3))
(('а', 'б', 'в'), ('а', 'б', 'г'), ('а', 'в', 'г'),
('б', 'в', 'г'


>>> import itertools
>>> list(itertools.comЬinations('aбвг', 2))
(('а', 'б'), ('а', 'в'), ('а', 'г'), ('б', 'в'), ('б', 'г'),
('в', 'г'}]
>>> ["" .join(i} for i in itertools.comЬinations ( 'абвг', 2)]
[
 'аб', 'ав', 'аг', 'бв ', 'бг', 'вг'
 ]
 2))
>>> list(itertools.comЬinations('вгaб',
(('в', 'г'), ('в', 'а'), ('в', 'б'), ('г', 'а'), ('г', 1 6 1
 ),
(•а', 'б')]
>>> list(itertools.comЬinations('aбвг', 3))
(('а', 'б', 'в'), ('а', 'б', 'г'), ('а', 'в', 'г'),
('б', 'в', 'г'


>>> list(itertools.comЬinations_with_replacement('aбвг', 2))
[ ( ( 1 'а• ' 'а•), 1}' (•а'' ( 1(51 f 'б 1)' ( (,а,, 1 В I f • I в' ) ' (•а•' ( 1 В I f • I г Г 1) f ' ( ( 1 1 б'' 'б')'
 Iб''
 'в 'г')' в' ) ' 1} г.' г. } ]
>>> list(itertools.comЬinations_with_replacement('вгaб', 2}
[ (
 1
 в', I В 1) I ('в 1 ' I Г 1) f ( 1 В I I , а,), ( 1 В 1 1 'б'}' ('г', •г'}'
(
 1
 Г I I


 •а')' 


 >>> from itertools import product
>>> list(product('абвг •, repeat=2))
[('а', 'а'), ('а', 'б'), ('а'' I В 1) 1 (,а,, • г.)' (. б 1' 'а')'
('б', 'б'), ('б', 'в'), ('б'' 'г')' (. в 1' ,а,), (.в 1, • б.)'
('в', 'в'), ('в', 'г'), ('г 1' 'а')' (.г 1, I б 1) I (. г 1 ' I в.)'
('г', 'г')]
>>> ["".join(i) for i in product ('аб', 'вг', repeat=l)]
[' ав', 'аг', 'бв', 'бг' ]
>>> ["".join(i) for i in product('aб', 'вг', repeat=2)]
[ 'авав • , 'аваг' , 'авбв' , • авбг', •агав', 'агаг', 'агбв',
'агбг', 'бвав', 'бваг', 'бвбв', 'бвбг', 'бгав', 'бгаг',
'бгбв', 'бгбг' ]

>>> irnport itertools
>>> def func(x): return х > 3
>>>
 list(itertools.filterfalse(func, [4, 5, 6, О, 7, 2, 3)))
[О,
 2, ЗJ
>>>
 list(filter(func, [4, 5, 6, О, 7, 2, 3]))
[4,
 5, 6, 7]
Если в первом параметре вместо названия функции указать значение None, то каждый
элемент последовательности будет проверен на соответствие значению False. Если эле­
мент в логическом контексте возвращает значение тrue, то он не войдет в возвращаемый ·
результат. Примеры:
 -\
>>>
 list(itertools.filterfalse(None, [О, 5, 6, О, 7, О, З]))
[О,
 О, О]
>>>
 list(filter:None, [О, 5, 6, О, 7, О, З]))
[5,
 б,
 7,
 3]


>>> [x * x for x in range(10)]
 # Генератор списков: конструирует список
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] # подобно вызову list(generator expr)
>>> (x * x for x in range(10))
 # Выражение-генератор: воспроизводит
<generator object at 0x009E7328>
 # элементы. Скобки часто необязательны
>>> {x * x for x in range(10)}
 # Генератор множеств, новинка в 3.0
{0, 1, 4, 81, 64, 9, 16, 49, 25, 36} # {x, y} – литерал множества в 3.0
>>> {x: x * x for x in range(10)}
 # Генератор словарей, новинка в 3.0
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}


>>> [x * x for x in range(10) if x % 2 == 0]
[0, 4, 16, 36, 64]
# Списки упорядочены
>>> {x * x for x in range(10) if x % 2 == 0}
{0, 16, 4, 64, 36}
# А множества - нет
>>> {x: x * x for x in range(10) if x % 2 == 0}
{0: 0, 8: 64, 2: 4, 4: 16, 6: 36}
# Как и ключи словаря
Вложенные циклы for также являются допустимыми, хотя неупорядоченная
природа обоих типов, не допускающая появления дубликатов, может несколь-
ко осложнять интерпретацию результатов:
>>> [x + y for x in [1, 2, 3] for y in [4, 5, 6]] # Списки сохраняют дубликаты
[5, 6, 7, 6, 7, 8, 7, 8, 9]
>>> {x + y for x in [1, 2, 3] for y in [4, 5, 6]} # А множества - нет
{8, 9, 5, 6, 7}
>>> {x: y for x in [1, 2, 3] for y in [4, 5, 6]} # Как и ключи словарей
{1: 6, 2: 6, 3: 6}

>>> {x + y for x in ‘ab’ for y in ‘cd’}
{‘bd’, ‘ac’, ‘ad’, ‘bc’}
>>> {x + y: (ord(x), ord(y)) for x in ‘ab’ for y in ‘cd’}
{‘bd’: (98, 100), ‘ac’: (97, 99), ‘ad’: (97, 100), ‘bc’: (98, 99)}
586	
 Глава 20. Итераторы и генераторы
>>> {k * 2 for k in [‘spam’, ‘ham’, ‘sausage’] if k[0] == ‘s’}
{‘sausagesausage’, ‘spamspam’}
>>> {k.upper(): k * 2 for k in [‘spam’, ‘ham’, ‘sausage’] if k[0] == ‘s’}
{‘SAUSAGE’: ‘sausagesausage’, ‘SPAM’: ‘spamspam’}




class MyError(Exception): pass
defstuff(file):
raise MyError()
file = open(‘data’, ‘w’)
 # Открыть файл для вывода
try:
stuff(file)
 # Возбуждает исключение
finally:
file.close()
 # Всегда закрывать файл, чтобы вытолкнуть буферы
print('not reached')
 # Продолжить с этого места,
# только если не было исключения
В этом фрагменте мы обернули вызов функции в инструкцию try с предложе-
нием finally, чтобы гарантировать, что файл будет закрыт при любых обстоя-
тельствах, независимо от того, будет возбуждено исключение в функции или
нет. При таком подходе расположенный далее программный код может быть
уверен, что содержимое выходных буферов файла было вытолкнуто из памяти
на диск. Подобная структура программного кода может гарантировать закры-
тие соединения с сервером и так далее.

try:
 # Объединенная форма
основное действие
except Exception1:
обработчик1
except Exception2:
обработчик2
...
else:
блок else
finally:
блок finally
Первым, как обычно, выполняется программный код в блоке основное действие.
Если при выполнении этого блока возбуждается исключение, выполняется
проверка всех блоков except, одного за другим, в поисках блока, соответствую-
щего возникшему исключению. Если было возбуждено исключение Exception1,
будет выполнен блок обработчик1, исключение Exception2 приведет к запуску
обработчика2 и так далее. Если исключение не было возбуждено, будет выполнен
блок else.
Независимо от того, что происходило раньше, блок finally будет выполнен
только после выполнения основных действий и после обработки любых воз-
